pragma solidity >=0.5.0 <0.6.0;

import "./zombiefactory.sol";

contract KittyInterface {
  function getKitty(uint256 _id) external view returns (
    bool isGestating,
    bool isReady,
    uint256 cooldownIndex,
    uint256 nextActionAt,
    uint256 siringWithId,
    uint256 birthTime,
    uint256 matronId,
    uint256 sireId,
    uint256 generation,
    uint256 genes
  );
}

contract ZombieFeeding is ZombieFactory {

  KittyInterface kittyContract;

  function setKittyContractAddress(address _address) external onlyOwner {
    kittyContract = KittyInterface(_address);
  }

  function _triggerCooldown(Zombie storage _zombie) internal {
    _zombie.readyTime = uint32(now + cooldownTime);
  }

  function feedAndMultiply(uint _zombieId, uint _targetDna, string memory _species) public {
    require(msg.sender == zombieToOwner[_zombieId]);
    Zombie storage myZombie = zombies[_zombieId];
    _targetDna = _targetDna % dnaModulus;
    uint newDna = (myZombie.dna + _targetDna) / 2;
    if (keccak256(abi.encodePacked(_species)) == keccak256(abi.encodePacked("kitty"))) {
      newDna = newDna - newDna % 100 + 99;
    }
    _createZombie("NoName", newDna);
    _triggerCooldown(myZombie);
  }

  function feedOnKitty(uint _zombieId, uint _kittyId) public {
    uint kittyDna;
    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
    feedAndMultiply(_zombieId, kittyDna, "kitty");
  }

}


// ------------------------
// Crypto-kitties contract
// ------------------------

// function getKitty(uint256 _id) external view returns (
//     bool isGestating,
//     bool isReady,
//     uint256 cooldownIndex,
//     uint256 nextActionAt,
//     uint256 siringWithId,
//     uint256 birthTime,
//     uint256 matronId,
//     uint256 sireId,
//     uint256 generation,
//     uint256 genes
// ) {
//     Kitty storage kit = kitties[_id];

//     // if this variable is 0 then it's not gestating
//     isGestating = (kit.siringWithId != 0);
//     isReady = (kit.cooldownEndBlock <= block.number);
//     cooldownIndex = uint256(kit.cooldownIndex);
//     nextActionAt = uint256(kit.cooldownEndBlock);
//     siringWithId = uint256(kit.siringWithId);
//     birthTime = uint256(kit.birthTime);
//     matronId = uint256(kit.matronId);
//     sireId = uint256(kit.sireId);
//     generation = uint256(kit.generation);
//     genes = kit.genes;
// }
// ------------------------

// ------------------------
// Javascript implementation
// ------------------------
// var abi = /* abi generated by the compiler */
// var ZombieFeedingContract = web3.eth.contract(abi)
// var contractAddress = /* our contract address on Ethereum after deploying */
// var ZombieFeeding = ZombieFeedingContract.at(contractAddress)

// // Assuming we have our zombie's ID and the kitty ID we want to attack
// let zombieId = 1;
// let kittyId = 1;

// // To get the CryptoKitty's image, we need to query their web API. This
// // information isn't stored on the blockchain, just their webserver.
// // If everything was stored on a blockchain, we wouldn't have to worry
// // about the server going down, them changing their API, or the company 
// // blocking us from loading their assets if they don't like our zombie game ;)
// let apiUrl = "https://api.cryptokitties.co/kitties/" + kittyId
// $.get(apiUrl, function(data) {
//   let imgUrl = data.image_url
//   // do something to display the image
// })

// // When the user clicks on a kitty:
// $(".kittyImage").click(function(e) {
//   // Call our contract's `feedOnKitty` method
//   ZombieFeeding.feedOnKitty(zombieId, kittyId)
// })

// // Listen for a NewZombie event from our contract so we can display it:
// ZombieFactory.NewZombie(function(error, result) {
//   if (error) return
//   // This function will display the zombie, like in lesson 1:
//   generateZombie(result.zombieId, result.name, result.dna)
// })